This is from a russian market from the creator of GrandCrab.


Привет Форумчане. На связи кодер краба,
Мы поведаем в этой небольшой статье об интерестных вещах простым языком, таким образом чтоб каждый мог примерно понять что из себя представляют дыры в ядре ос Windows.
Использовать мы будем язык программирования C.
В данной статье дизассемблируется драйвер под x64 версию Windows в поисках уязвимости.

Цель: найти 0day уязвимость
Продукт: AhnLab V3 Lite ( корейский антивирус )
Результат: Arbitrary Memory Overwrite, приводящий в перспективе к LPE. В качестве PoC используется DoS-эксплойт ахнлаба:

http://filestorage.biz/download.php?file=e...84050d41e254261
Пароль GandCrab

Начнём с некоторых базовых вещей:

1) Теория

На сегодняшний день в антивирусных продуктах выработалось чёткое правило: Антивирусная программа должна иметь компонент режима ядра.
С чем это связано? Дело в том, что контролировать поведение приложений и такие вещи как сетевой траффик значительно проще и эффективнее из режима ядра.
В пользовательском режиме, существует масса ухищрений позволяющих обмануть проактивную защиту или прервать работу антивируса.
Соотвественно если же часть антивируса находится в виде драйвера в ядре, то антивирус имеет максимальные привилегии которые позволяют ему фильтровать любые действия с ос/железом.

Что такое драйвер? Да по сути это тот же самый PE ( его внутренняя структура схожа с EXE файлом ), только загружается он в контексте режима ядра и по функционалу больше похож на дллку.
Точка входа драйвера обычно называется DriverEntry и принимает она два аргумента

Код

NTSTATUS DriverEntry(
 _In_ struct _DRIVER_OBJECT *DriverObject,
 _In_ PUNICODE_STRING       RegistryPath
);




Первый аргумент, это объект драйвера, который позволит задать обработчики для IRP запросов и дать нам возможность общаться с пользовательского режима с драйвером, посредством IOCTL.


IRP: I/O request packet сокращённо, специальные пакеты через которые драйвера могут общаться друг с другом а также с компонентами из пользовательского режима
Irp имеет следующую структуру

Код

typedef struct _IRP {
 PMDL            MdlAddress;
 ULONG           Flags;
 union {
   struct _IRP  *MasterIrp;
   PVOID       SystemBuffer;
 } AssociatedIrp;
 IO_STATUS_BLOCK IoStatus;
 KPROCESSOR_MODE RequestorMode;
 BOOLEAN         PendingReturned;
 BOOLEAN         Cancel;
 KIRQL           CancelIrql;
 PDRIVER_CANCEL  CancelRoutine;
 PVOID           UserBuffer;
 union {
   struct {
     union {
       KDEVICE_QUEUE_ENTRY DeviceQueueEntry;
       struct {
         PVOID DriverContext[4];
       };
     };
     PETHREAD   Thread;
     LIST_ENTRY ListEntry;
   } Overlay;
 } Tail;
} IRP, *PIRP;


Драйвера могут выстраиваться в цепочки, например мы можешь создать драйвер фильтр для определённого виртуального устройства и фильтровать IRP запросы к нему, либо передавая их дальше, либо отсекая лишнее.
Для этого у каждой структуры IRP вылеляет так называемый блок стека для драйвера: IO_STACK_LOCATION которая находится в Irp->Tail.Overlay
Когда Irp запрос инициируется для \Device\Tcp, на который мы создали драйвер фильтр ( пусть он будет называться \Device\FilterTcp ),
система ввода вывода Windows грубо говоря посмотрев на количество устройств в цепочке, создаст соотвественно два блока стека IO_STACK_LOCATION для нашего фильтра и непосредственно для \Device\Tcp.
При этом по правилам в фильтре мы должны были бы вызвать IoGetNextIrpStackLocation и подготовить IRP для следующего драйвера в цепочке, после необходимой фильтрации.

IO_STACK_LOCATION содержит в себе необходимые параметры для IRP запроса, буффер с входными данными, буфер для выходных данных и так называемые коды Irp функций.
Драйвер регистрирует обработчики на каждый из данных кодов, список можно найти тут https://docs.microsoft.com/en-us/windows-ha...-function-codes
Нас будет интересовать IRP_MJ_DEVICE_CONTROL так как именно он выставляется в IO_STACK_LOCATION при вызове DeviceIoControl с IOTCL кодом операции.

IOCTL: Input Output Control - Это собственно запрос к драйверу в виде 32х битной константы, который пробрасывается через IRP пакет в драйвер.


Далее чтобы собственно обратиться к драйверу, необходимо в нём создать виртуальное устройство через IoCreateDevice и символическую ссылку для этого устройства через IoCreateSymbolicLink.
Данная символическая ссылка будет передаваться функции CreateFile в пользовательском режиме и далее через DeviceIoControl мы сможем отправлять IRP запросы драйверу.



2) Переходим к практике: Ahnlab V3 Security Lite.

Нами был выбран бесплатный корейский антивирус Ahnlab V3 Security Lite, так как он создал порядочно проблем для нашего локера.
Итак, была поднята VmWare с Windows 10 x64 с пакетом корейского языка, туда был проинсталлен данный антивирус.
Далее после перевода в отладочный режим, мы подключаемся через IDA Pro + Windbg плагин к ядру и начинаем отлаживать.


Уязвимым драйвером является TfFRegNt.sys ( лежит тут: C:\Program Files\AhnLab\V3Lite30\ )
Соотвественно далее пойдёт x64 ассемблер. Соотвественно первые четыре параметра при выз
